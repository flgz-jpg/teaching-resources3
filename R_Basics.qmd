---
title: "R Basics"
---

Diese Seite einthält eine Reihe R-Befehle, welche dabei helfen, erfolgreich in ein R-Projekt zu starten. Es werden die Grundlagen für das Einlesen und Kennenlernen neuer Daten, sowie erste Bearbeitungsschritte zusammengefasst.

### Den Working Directory setzen: Wo findet R die Daten?

Eine häufige Fehlermeldung beim Einlesen von Daten ist "no such file or directory". Die häufigste Ursache ist, dass nicht spezifiziert wurde, über welchen Weg (directory) R auf den Datensatz zugreifen soll.

::: callout-warning
Es empfielt sich, alle für eine R Session relevanten Dateien im selben Ordner abzulegen, damit der Working Directory nicht innerhalb einer R-Session immer wieder neu gesetzt werden muss.
:::

``` r

#mit folgendem Befehl kann der Working Directory festgelegt werden:

setwd()

#Manuell: Manüleiste > Session > Set Working Directory > Choose Directory...

#welchen Working Directory R gerade verwendet, verrät folgender Befehl:

getwd()
```

### R Packages und Befehle

R ist eine Open Source Software, für die jede:r Befehle entwickeln kann. Befehle, die nicht zur R Software selber gehören, sind in sogenannten **packages** abgelegt.

Damit die Befehle eines Packages verwendet werden können, muss das entsprechende Package geladen werden (so lässt sich im Umkehrschluss verhindern, dass sich die Befehle unterschiedlicher Packages in die Quere kommen - bspw. weil sie ähnlich heissen oder anderweitig konfligieren).

Voraussetzung für das Laden eines Packages ist, dass es bereits installiert wurde.

``` r
install.packages("carData") # packes installieren
library(carData) # package laden
library(dplyr, jtools) # mehrere packages gleichzeitig laden
detach(carData, unload = TRUE) # laden von packages rückgängig machen
```

### Daten einlesen

Mit R lassen sich unterschiedliche Daten-Formate einlesen. Je nach dem, wie der Datensatz gespeichert ist (bspw. in einer Excel-Tabelle .xlx oder im Textformat .txt) wird ein anderer Befehl verwendet.

Manche Befehle sind flexibel: Read.csv2 ist primär auf Daten ausgelegt, deren Werte mit Kommas getrennt werden (comma seperated values), mit "sep = "" lässt sich aber spezifizieren, ob die Werte durch Kommas, Semicolons oder Abstände getrennt sind.

``` r

# Excel
excel_data = read_excel()

# Tabellen 
table_data = read.delim2()

# Komma-getrennte Werte (oder Werte, die durch Semicolons oder Abstände getrennt sind - eignet sich generell gut für Numbers-Datein auf Mac)
csv_data = read.csv2() #Beispiel: csv_data = read.csv2(file, sep = ";")
```

### Daten kennen lernen

Um die folgenden Schritte zu illustrieren, verwenden wir den in R enthaltenen Datensatzes Cars93, der Daten zu 93 US-amerikanischen Autos aus dem Jahr 1993 enthält. Der Datensatz muss nicht eingelesen werden; R kann direkt auf ihn zugreifen.

``` r

# Um sich einen groben Überblick zu verschaffen: 

## Den Datensatz anzeigen (in separatem Fenster)
View(Cars93)

## Teile des Datensatzes anzeigen (in der Console)
head(Cars93) # zeigt die obersten Zeilen des Datensatzes "Cars93" an
tail(Cars93) # zeigt die letzten Zeilen des Datensatzes "Cars93" an

## Die Werte im Datensatz verstehen
str(Cars93) # gibt die Struktur der Variablen des Datensatzes "Cars93" an

## Die Grobstruktur des Datensatzes verstehen
is.data.frame(Cars93) #handelt es sich um einen Cars93 Frame?
is.table(Cars93) #handelt es sich um eine Tabelle
nrow(Cars93) #Anzahl Zeilen (meistens Beobachtungen / Subjects)
ncol(Cars93) #Anzahl Spalten (meistens Variablen)
length(unique(Cars93$study_id)) #Anzahl unterschiedlicher Study Id's, sofern diese unter "study_id" aufgeführt sind
```

### Variablen-Typen in R

-   **Logical**: Logicals sind boolsche Variablen, d.h., sie können die Werte TRUE oder FALSE annehmen.

``` r
b = TRUE
is.logical(b) # anhand is.logical() lässt sich herausfinden, ob eine Variable ein logical ist
```

-   **Factor**: Faktors sind ordinal skalierte Werte; sie sind kategorial, haben keine interpretierbaren Abstände, können aber hierarchische Beziehungen abbilden. Zulässige Operationen sind: gleich, ungleich, grösser und kleiner als. Mit str() lässt sich herausfinden, wieviele Abstufungen ein Factor hat.

``` r
str(Cars93$Origin) # str() gibt den Variablen-Typ aus. 
is.factor(Cars93$Origin) # Alternativ kann mit is.factor spezifisch danach gefragt werden, ob es sich um einen Faktor handelt
```

-   **Integer**: Integer sind Variablen, die Ereignisse anhand positiver oder negativer ganzer Zahlen kodieren. Das bedeutet, dass sie keine Nachkommastellen haben. Das kann zu Schwierigkeiten bei Berechnungen führen. In diesem Fall sollten sie in numerische Werte umgewandelt werden.

``` r
is.integer(Cars93$RPM) 
Cars93$RPM = as.numeric(Cars93$RPM) # Wandelt einen Integer in eine numerische Variable um 
```

-   **Numeric**: Numerische Variablen kodieren Ereignisse anhand reeller Zahlen. Das bedeutet, dass sie alle Punkte auf einem Zahlenstrahl abbilden und beliebigen Transformationen (Berechnungen) unterzogen werden können.

(Für diejenigen, die es genau wissen wollen: Intern sind numerische Werte mit *x = (-1)\^s \* m \* b\^e* abgespeichert (d.h. als Gleitkommazahl).

-   **Character**: Character sind Zeichenketten, auch *strings* genannt, deren Elemente in Anführungsstrichen gespeichert werden.

### Daten bearbeiten

::: {.callout-warning title="Der Erste Bearbeitungsschritt"}
Nach dem Einlesen und Kennenlernen der Daten sollte der erste Bearbeitungsschritt immer das Erstellen einer Kopie der Daten sein. So muss der Datensatz nicht immer wieder neu eingelesen werden, falls bei einem Bearbeitungsschritt etwas schief geht.

``` r
df1 = df_org # Ein neues Objekt namens "df1" erstellen, in das die Inhalte von df_org abgelegt werden

# In diesem Fall ist df1 eine exakte Kopie von df_org. df_org bleibt dabei unverändert.
```
:::

Df steht hier für data frame, welches das übliche Format für Datensätze in R ist und von den meisten Befehlgruppen zur Datenbearbeitung genutzt wird.

Folglich ist eine häufige Quelle für Fehlermeldungen, das Datensätze noch nicht in die data frame Struktur gespeichert sind.

``` r
is.data.frame(df1) # prüfen, ob es sich bei df1 um einen data frame handelt
as.data.frame(df1) # df1 in einen data frame umwandeln
df2 = as.data.frame(df2) # ein neues Objekt erstellen, in das die Inhalte von df1 in der data frame Struktur abgelehgt werden
```

## Subsets erstellen

Subsets oder Subsamples werden immer dann erstellt, wenn nur ein Teil des Datensatzes bearbeitet werden soll oder wenn Teile des Datensatzes getrennt betrachtet werden sollen. Das ist u.a. dann der Fall, wenn mit Teilstichproben gearbeitet wird. Manchmal verlangt auch die Struktur der Daten, dass der Datensatz aufgeteilt und nach der Bearbeitung wieder zusammen gesetzt wird.

Wir erstellen einen fiktiven Datensatz, um die folgenden Operationen anwenden zu können

```{r}
set.seed(123)
n <- 200
df <- data.frame(
  id = 1:n,
  age = sample(18:90, n, replace = TRUE),
  sex = sample(c("M", "F", "X"), n, replace = TRUE),
  income = round(rlnorm(n, meanlog = 10, sdlog = 0.6)), 
  relationship_status = sample(c("single", "monogamous relationship", "polyamorous relationship", "divorced / widowed",  NA), n, replace = TRUE, prob = c(0.45,0.35,0.12,0.05,0.03)),
  score = rnorm(n, 100, 15),
  date_joined = sample(seq(as.Date("2018-01-01"), as.Date("2024-12-31"), by = "day"), n, replace = TRUE),
  stringsAsFactors = FALSE
)
# wir fügen ein paar Missings hinzu
df$income[sample(1:n, 10)] <- NA
df$score[sample(1:n, 8)] <- NA
```


``` r
# Eine Teilstichprobe erstellen

## Nach Eigenschaften filtern
junge_erwachsene <- df[df$age >= 18 & df$age <= 35, ] # Teilstichprobe mit Personen zwischen 18 und 35
recent_members <- df %>% filter(date_joined >= as.Date("2023-01-01")) # Teilstichprobe anhand des Teilnahmezeitpunkts

library(dplyr)
young_adults_dplyr <- df %>% filter(age >= 18, age <= 35)

## Eine Teilstichprobe mit interessierenden Variablen
library(data.table)
DT <- as.data.table(df) 
DT_subset <- DT[age >= 30 & sex == "F", .(id, age, sex, income)] # Study Id, Alter, Geschlecht und Einkommen von Frauen über 30

## Zufallsauswahl

sample_idx <- sample(seq_len(nrow(df)), size = 30) # erstelle ein Objekt, welches eine Zufallsauswahl der Beobachtungen in df enthält
df_simple_sample <- df[sample_idx,] # filtere diese Zufallsauswahl aus df heraus und lege sie in ein neues Objekt ab

library(dplyr)
df_sample_n <- df %>% sample_n(30) # wähle mit dplyr 30 zufällige Beobachtungen und lege sie in ein neues Objekt ab
df_sample_frac <- df %>% sample_frac(0.10)  # filtere mit dplyr zufällig eine Fraktion (hier 10%) aus df und lege sie in ein neues Objekt ab
 
## Stratifizierte Stichprobe

stratified <- df %>% group_by(sex) %>% slice_sample(n = 5) %>% ungroup() # Teilstichprobe mit je 5 Personen pro Geschlecht
stratified_frac <- df %>% group_by(sex) %>% slice_sample(prop = 0.1) %>% ungroup() # Teilstichprobe aus je 10% der Personen jeden Geschlechts

```

## Variablen erstellen und umkodieren

```r
# Wenn, dann
df$income_level = ifelse(df$income >= 26677, "high", "low") # wenn income  >= 26677, ist es "high", ansonsten ist es "low"

# Kategorien basierend auf mehreren Bedingungen
df$income_level2 = ifelse(!is.na(df$income) & df$income >= 26677 , "high", ifelse(!is.na(df$income) & df$income < 26677, "low", "NA"))

# Werte in Kategorien unterteilen
df$age_group = cut(df$age, breaks = c(0, 25, 35, 50, 65, Inf), # Teile die Werte für "age" in unterschiedliche Intervalle
                    labels = c("<=25","26-35","36-50","51-65","66+"), right = TRUE) # füge den Intervallen labels hinzu

# Dummay-Variablen erstellen

dummies <- model.matrix(~ sex - 1, data = df) # erstelle eine Dummy-Matrix aus den Werten für Sex
df_dummies <- cbind(df, dummies) # füge die Matrix dem originalen Datensatz hinzu

# recode()
sex_recoded = recode(df$sex, "M" = "male", "F" = "female", "X" = "diverse", .default = NA_character_)

# mutate() mit case_when()
df3 <- df %>%
  mutate( # verändere die Variablen-Werte
    income_band = case_when(
      is.na(income) ~ "Missing", # wenn income NA, dann ersetze mit "Missing"
      income < 30000 ~ "<30k", 
      income >= 30000 & income < 70000 ~ "30-70k", # wenn income zwischen 30000 und 70000 liegt, dann ersetze mit "30-70k"
      income >= 70000 & income < 150000 ~ "70-150k",
      income >= 150000 ~ "150k+"
    )
  )
  
```

*in progress ... *